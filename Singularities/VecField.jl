import AbstractAlgebra, GAP, Hecke, Nemo, Singular, Polymake

using Markdown

include("Diagonal.jl")

###############################################################################
#
#   Derivation module related functions
#
###############################################################################

@doc Markdown.doc"""
 derivation_module(I::sideal; order0::Bool, standardBasis::Bool)
> Computes the module of logarithmic Derivations of $I$. If "order0" is
> set to true, only the elements of order $\geq 0$ are computed. If
> "standardBasis" is set to true, a standard basis for the module is returned.
"""

function derivation_module(I::Union{Singular.spoly{T}, Singular.sideal{T}}; order0::Bool=false, standardBasis::Bool=false) where T <: AbstractAlgebra.RingElem

## Consider different types of input

a = order0
b = standardBasis

if typeof(I) == Singular.spoly{Singular.n_Q}
   R = parent(I)
	return derivation_module(Singular.Ideal(R, I), order0 = a, standardBasis = b)
end

R = Singular.base_ring(I)
n = Singular.nvars(R)
m = Singular.ngens(I)
G = Singular.gens(I)

if !order0 
   if iszero(I)
		return Singular.FreeModule(R, n)
	end
   J = Singular.jacobian_matrix(G)

   ##Construct the Singular matrix, whose rows are the generators of the module
	for i in 1:m
		J = hcat(J, I[i]*Singular.identity_matrix(R, m))
	end

else 
   M = MaximalIdeal(R, 1)
   ## Catch case I == 0
	if iszero(I)

		J = M[1]*Singular.identity_matrix(R, n)
		##Construct the Singular matrix, whose rows are the generators of the module
		for i in 2:n
			J = hcat(J, (M[i]*Singular.identity_matrix(R, n)))
		end
   else
      ##Do I != 0
	   J = Singular.jacobian_matrix(G)
	   J = vcat(J, Singular.identity_matrix(R, n))

	   ##Construct the Singular matrix, whose rows are the generators of the module
	   for i in 1:n
		   M1 = vcat(Singular.zero_matrix(R, m, n), M[i]*Singular.identity_matrix(R, n))

		   if i<=m
		   M2 = vcat(I[i]*Singular.identity_matrix(R, m), Singular.zero_matrix(R, n, m))
		   else
		   M2 = Singular.zero_matrix(R, m + n, m)
		   end
		   M3 = hcat(M2, M1)
		   J = hcat(J, M3)
	   end
   end
end
	##Convert Singular matrix to Array in order to obtain smodule #TODO:Automatize
	k1 = Singular.nrows(J)
	k2 = Singular.ncols(J)
	A = zeros(R, k1, k2)

	for i in 1:k1
		for j in 1:k2
		   A[i, j] = J[i, j]
		end
	end

	S = syz(Module(A))

	##Truncate the syzygies in order to obtain the projection to the first
	## n entries.
	l = Singular.ngens(S)
	r = S[1].rank
	B = zeros(R, r, l)
	for i in 1:l
		B[1:r,i]=Array(S[i])
	end
	# Generate module and remove unnecessary zeroes
	N = Module(B[1:n, 1:l])
	Singular.libSingular.idSkipZeroes(N.ptr)
	if standardBasis
		return std(N)
	end
	return N


end

@doc Markdown.doc"""
 analyticTriviality(I::Union{Singular.spoly{T}, Singular.sideal{T}}) where T <: AbstractAlgebra.RingElem
> Returns the dimension of analytic triviality of the ideal generated by $I.$
"""

function analyticTriviality(I::Union{Singular.spoly{T}, Singular.sideal{T}}) where T <: AbstractAlgebra.RingElem
    if typeof(f)==Singular.spoly{T}
        R = Singular.parent(f)
    elseif typeof(f)==Singular.sideal{T}
        R = Singular.base_ring(f)
    end

    if !has_local_ordering(R)
      error("The ordering is not local.")
    else
        M = derivation_module(I)
        return rank(derivation_module_get_constant_part(M))
    end
end

###############################################################################
#
#   Applying derivations
#
###############################################################################

function apply_vecfield(v::Singular.svector, p::Singular.spoly)
   R = base_ring(v)
   n = Singular.nvars(R)
   
   v.rank != n && error("Dimension mismatch.")   

   A = Array(v)
   J = elem_type(R)[derivative(p, i) for i in 1:n]
   return dot(A, J)
end

function apply_vecfield(v::Singular.svector, I::Singular.sideal)
   R = Singular.base_ring(v)
   n = Singular.nvars(R)
   m = Singular.ngens(I)
   v.rank != n && error("Dimension mismatch.")   

   A = Array(v)
   B = Array{elem_type(R), 1}()
   for j in 1:m
      J = elem_type(R)[derivative(I[j], i) for i in 1:n]
      push!(B, dot(A, J))
   end
   return Singular.Ideal(R, B)
end

###############################################################################
#
#   Representation matrices of derivations
#
###############################################################################

@doc Markdown.doc"""
 derivation_module_get_linear_part(M::smodule)
> Returns an array of AbstractAlgebra matrices of the linear parts of the 
> generators of M. The input needs to be the smodule resulting from
> derivation_module.
"""

function derivation_module_get_linear_part(M::Singular.smodule)
	R = Singular.base_ring(M)
	BR = Singular.base_ring(R)
	n = Singular.nvars(R)
	m = Singular.ngens(M)

	Z = AbstractAlgebra.zero_matrix(BR, n, n)

	return [get_linear_part(M[i]) for i in 1:m if get_linear_part(M[i])!=Z]
	#TODO: add type to array
end

@doc Markdown.doc"""
 derivation_to_matrix(v::Singular.svector{Singular.n_Q}, 
         I::Singular.sideal{Singular.n_Q})
> Returns the representation matrix over a $\Q$-basis $B$ of a zero-dimensional
> ideal.
"""

function derivation_to_matrix(v::Singular.svector{Singular.spoly{Singular.n_Q}}, 
         B::Array{Singular.spoly{Singular.n_Q}, 1})

	R = base_ring(v)
   BR = base_ring(R)
	n = nvars(R)
   m = length(B)

   v.rank != n && error("Dimension mismatch.")

   # Construct matrix
   M = zeros(BR, m, m)
   for i in 1:m
      p = apply_vecfield(v, B[i])      
      for j in 1:m
         M[j, i] = Singular.coeff(p, B[j])
      end
   end
   return M
end

@doc Markdown.doc"""
 derivation_to_matrix(v::Singular.svector{Singular.n_Q}, 
         I::Singular.sideal{Singular.n_Q})
> Returns the representation matrix over a $\Q$-basis $B$ of a zero-dimensional
> ideal.
"""

function matrix_to_derivation(R::Singular.PolyRing, M::Array{Singular.n_Q, 2}, B::Array{Singular.spoly{Singular.n_Q}, 1})

   BR = base_ring(R)
	n = nvars(R)
   m = length(B)

   size(M) != (m, m) && error("Dimension mismatch.")

   # Construct derivation
   L = Array{Singular.spoly{Singular.n_Q}, 1}()
   for i in 1:n
      push!(L, dot(B, R.(M[:, i])))
   end
   F = Singular.FreeModule(R, n)
   return F(L)
end

###############################################################################
#
#   Computing toral Lie algebra with GAP
#
###############################################################################

function derivation_toral_lie_algebra_representation(M::Singular.smodule{Singular.spoly{Singular.n_Q}}, 
               B::Array{Singular.spoly{Singular.n_Q}, 1})
   R = Singular.base_ring(M)
   n = Singular.ngens(M)
   L = [derivation_to_matrix(M[i], B) for i in 1:n]

   ## Convert matrices from SingularQQ to JuliaQQ
   L = convert_singularQQ_to_juliaQQ(L) 

	## Pass Objects to GAP to perform Lie algebra computations

	LG = GAP.julia_to_gap(L, Val(true)) ## Val(true) needed for recursion

	LG = GAP.Globals.LieAlgebra(GAP.Globals.Rationals, LG)
   
	C = GAP.Globals.LieCenter(GAP.Globals.CartanSubalgebra(LG))

	## List of Basis vectors of C
	C = GAP.Globals.BasisVectors(GAP.Globals.Basis(C))

	## Get the semi-simple parts and get a basis for the toral Lie algebra
	C = [GAP.Globals.JordanDecomposition(GAP.Globals.List(C[i]))[1] for i in 1:length(C)]

	C = GAP.Globals.LieAlgebra(GAP.Globals.Rationals, GAP.julia_to_gap(C))

	C = GAP.Globals.Basis(C)

	## Convert GAP output into list of SINGULAR matrices(for the moment)
	r = length(C)
	s = GAP.Globals.NrRows(C[1])
	#Transposition muss im folgenden hin, da die matrizen ansonsten transponiert sind!!!
	L = [Hecke.matrix(reshape(Hecke.QQ.([GAP.gap_to_julia(C[i][k, j]) for j in 1:s for k in 1:s]), s, s)) for i in 1:r]
   #print("\n", "Toral Lie Algebra Matrices:",L, "\n")
   return L
end

function derivation_toral_lie_algebra(M::Singular.smodule{Singular.spoly{Singular.n_Q}}, 
               B::Array{Singular.spoly{Singular.n_Q}, 1})
#TODO: Make it work
   L = derivation_toral_lie_algebra_representation(M, B)
   LL = [Singular.QQ(L[i]) for i in 1: length(L)]
	return [ matrix_to_derivation(R, L[i], B) for i in 1: length(L)]
end

###############################################################################
#
#   Computing coordinate changes for toral Lia algebras
#
###############################################################################

function get_coord_change(T::Array{U}, n::Int, B::Array{Singular.spoly{Singular.n_Q}, 1}) where U <: Hecke.MatElem{F} where F <: Hecke.FieldElem

   Tlin = [T[i][1: n, 1: n] for i in 1: length(T)]
   K = getSplittingField(Tlin)
   Tlin = [Hecke.matrix(reshape(K.(Tlin[i]), n, n)) for i in 1: length(Tlin)]
   #print("\n", "T:", T, "\n") 
   # Create new poly ring we work over
   C = CoefficientRing(K)
   R = parent(B[1])
   S, = Singular.PolynomialRing(C, [String(v) for v in symbols(R)], ordering = R.ord) 
   
   # Construct monomial basis over new coefficient ring
   Bnew = [change_base_ring(b, C, S) for b in B]
   
   # Do the linear algebra and compute the transformation map
   D1 = multispectrum(Tlin)
   #print("\n", "Multispectrum=:", D1, "\n")
   Id = [S(0) for i in 1:n]
   k = 1
   Z = [K(0) for i in 1:length(Tlin)]
   for d in keys(D1) 
      # Build the weight matrix
      for l in 1:D1[d]
         Z = Hecke.hcat(Z, d)
      end
      # Build the map
      E = multieigenspace(T, d)
      #print("E, d =", "\n", E, "\n",d,"\n")
      r = Hecke.nrows(E)
      Elin = Hecke.hcat(E[:, 1:n], Hecke.identity_matrix(K, r))
      Elin = Hecke.rref(Elin)[2]
      E = Elin[:, n + 1: n + r]*E
      j = 1
      for i in 1:r
         piv = Hecke.pivot(E, i)
         if piv <= n
            Id[k] = dot(E[i,:], Bnew)
            j += 1
            k += 1
            if j > D1[d]
               break
            end
         end
      end
   end
   
   # Build matrix as rational matrix with integral entries
   Z = Hecke.rref(Hecke.matrix(Z[:, 2: end]))[2]
   sz = size(Z)
   #print("\n", "Z=:", Z, "\n")
   A = reshape(Rational.(Z), sz[1], sz[2])
   #print("A=","\n", A, "\n")
   for i in 1: sz[1]
      A[i, :] = lcm(denominator.(A[i, :]))* A[i, :]
   end

   # Build output map
   phi = AlgebraHomomorphism(S, S, Id)
   
   # Return output
   return (S, phi, A)
end

###############################################################################
#
#   Derivation module auxilliary functions
#
###############################################################################

function derivation_module_get_constant_part(M::Singular.smodule{T}) where T <: AbstractAlgebra.RingElem

	R = base_ring(M)
	n = nvars(R)
	N = deepcopy(M)
	N = jet(N, 0)

	##Obtain the array corresponding to N
	l = Singular.ngens(N)
	r = N[1].rank
	A = zeros(R, r, l)
	for i in 1:l
		A[1:r, i]=Array(N[i])
	end

	##Convert the constant entries of A to the type of the base field of R
	BR = base_ring(R)
	B = zeros(BR, r, l)

	for i in 1:r
		for j in 1:l
		C = collect(coeffs(A[i, j]))
		if length(C) == 0
			B[i, j] = BR(0)
		else
			B[i, j] = collect(coeffs(A[i, j]))[1]
		end
		end
	end
	return AbstractAlgebra.matrix(TT, B)

end

@doc Markdown.doc"""
 get_linear_part(v::svector)
> Returns the matrix of the linear part of a derivation.
> The input needs to be the svector resulting from derivation_module.
"""

function get_linear_part(v::Singular.svector)
	R = base_ring(v)
	BR = base_ring(R)
	n = nvars(R)
	w = Array(jet(v, 1) - jet(v, 0))
	B = zeros(BR, n, n)
	for i in 1:n

		for j in 1:n
			p = derivative(w[i],j)
			C = collect(coeffs(p))
			if length(C) != 0
				B[i, j] = collect(coeffs(p))[1]
			end
		end

	end
	return B
	##return AbstractAlgebra.matrix(BR,B)
end

function get_sorted_kbasis(I::Singular.sideal)
   # Catch particular cases and check dimensions
   if !I.isGB
      I = std(I)
   end

   !iszerodim(I) && error("Ideal has to be zero-dimensional")
   
   R = base_ring(I)
   n = nvars(R)
   
   # Sort basis by degree, s.th. x1,x2,..,xn are the first n entries   
   B = gens(kbase(I))
   sort!(B, by = Singular.total_degree)
   B = B[2: end]
   B[1: n] = sort(B[1: n], by = Singular.var_index)
   return B
end
